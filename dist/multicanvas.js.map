{"version":3,"sources":["webpack://WaveSurfer/webpack/universalModuleDefinition","webpack://WaveSurfer/webpack/bootstrap","webpack://WaveSurfer/./node_modules/debounce/index.js","webpack://WaveSurfer/./src/drawer.canvasentry.js","webpack://WaveSurfer/./src/drawer.js","webpack://WaveSurfer/./src/drawer.multicanvas.js","webpack://WaveSurfer/./src/util/ajax.js","webpack://WaveSurfer/./src/util/extend.js","webpack://WaveSurfer/./src/util/fetch.js","webpack://WaveSurfer/./src/util/frame.js","webpack://WaveSurfer/./src/util/get-id.js","webpack://WaveSurfer/./src/util/index.js","webpack://WaveSurfer/./src/util/max.js","webpack://WaveSurfer/./src/util/min.js","webpack://WaveSurfer/./src/util/observer.js","webpack://WaveSurfer/./src/util/prevent-click.js","webpack://WaveSurfer/./src/util/request-animation-frame.js","webpack://WaveSurfer/./src/util/style.js"],"names":["debounce","func","wait","immediate","timeout","args","context","timestamp","result","later","last","Date","now","setTimeout","apply","debounced","arguments","callNow","clear","clearTimeout","flush","module","exports","CanvasEntry","wave","waveCtx","progress","progressCtx","start","end","id","constructor","name","toLowerCase","canvasContextAttributes","element","getContext","elementWidth","totalWidth","width","height","offsetLeft","elementSize","hasProgressCanvas","clearRect","canvas","waveColor","progressColor","fillStyle","x","y","radius","fillRectToContext","ctx","drawRoundedRect","fillRect","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","peaks","absmax","halfH","offsetY","drawLineToContext","length","first","Math","round","canvasStart","canvasEnd","scale","halfOffset","absmaxHalf","i","peak","h","halfPixel","j","format","quality","type","Promise","resolve","toBlob","toDataURL","Drawer","container","params","pixelRatio","lastPos","wrapper","el","styles","util","style","appendChild","document","createElement","display","position","userSelect","webkitUserSelect","fillParent","scrollParent","overflowX","hideScrollbar","overflowY","setupWrapperEvents","e","noPrevent","preventDefault","clientX","targetTouches","bbox","getBoundingClientRect","nominalWidth","parentWidth","getWidth","rtl","right","left","scrollLeft","scrollWidth","addEventListener","scrollbarHeight","offsetHeight","clientHeight","clientY","bottom","interact","fireEvent","handleEvent","setWidth","clearWave","barWidth","drawBars","drawWave","percent","recenterOnPosition","half","clientWidth","maxScroll","target","offset","rate","autoCenterRate","max","min","updateSize","minPxDelta","pos","autoCenter","newPos","autoCenterImmediately","updateProgress","unAll","parentNode","removeChild","channelIndex","Observer","MultiCanvas","maxCanvasWidth","maxCanvasElementWidth","canvases","progressWave","EntryClass","drawingContextAttributes","overlap","ceil","barRadius","createWrapper","createElements","zIndex","top","overflow","boxSizing","borderRightStyle","pointerEvents","addCanvas","updateCursor","borderRightWidth","cursorWidth","borderRightColor","cursorColor","requiredCanvases","removeCanvas","canvasWidth","lastCanvas","forEach","entry","updateDimensions","makeInset","leftOffset","initWave","initProgress","push","lastEntry","parentElement","destroy","pop","frame","prepareDraw","hasMinVals","undefined","peakIndexScale","bar","gap","barGap","step","halfHmod","reflection","floor","abs","barMinHeight","reflectedPeaks","len","drawLine","splitChannelsOptions","channelColors","setFillStyles","drawLines","startCanvas","endCanvas","intersection","x1","y1","x2","y2","fillRects","splitChannels","filterChannels","includes","fn","drawIndex","Array","channels","filteredChannels","filter","c","hideChannel","overlay","setHeight","channelPeaks","indexOf","barHeight","normalize","some","call","val","all","map","getImage","images","rightInset","actualWidth","ajax","options","instance","xhr","XMLHttpRequest","fired100","open","method","url","responseType","requestHeaders","header","setRequestHeader","key","value","withCredentials","lengthComputable","loaded","total","status","response","send","extend","dest","console","warn","sources","source","Object","keys","ProgressHandler","contentLength","_reader","body","getReader","parseInt","controller","read","then","done","onProgress","close","byteLength","enqueue","catch","error","fetchFile","Error","fetchHeaders","Headers","fetchRequest","Request","AbortController","append","fetchOptions","headers","mode","credentials","cache","redirect","referrer","signal","fetch","progressAvailable","documentMode","test","navigator","userAgent","get","Response","ReadableStream","errMsg","ok","arrayBuffer","json","blob","text","getId","prefix","random","toString","substring","values","largest","Infinity","smallest","Number","_disabledEventEmissions","handlers","event","callback","un","splice","handler","on","eventNames","_isDisabledEventEmission","preventClickHandler","stopPropagation","removeEventListener","preventClick","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","bind","prop"],"mappings":"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","file":"multicanvas.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/drawer.multicanvas.js\");\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","/**\n * @since 3.0.0\n */\n\nimport style from './util/style';\nimport getId from './util/get-id';\n\n/**\n * The `CanvasEntry` class represents an element consisting of a wave `canvas`\n * and an (optional) progress wave `canvas`.\n *\n * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to\n * render a waveform, depending on the zoom level.\n */\nexport default class CanvasEntry {\n    constructor() {\n        /**\n         * The wave node\n         *\n         * @type {HTMLCanvasElement}\n         */\n        this.wave = null;\n        /**\n         * The wave canvas rendering context\n         *\n         * @type {CanvasRenderingContext2D}\n         */\n        this.waveCtx = null;\n        /**\n         * The (optional) progress wave node\n         *\n         * @type {HTMLCanvasElement}\n         */\n        this.progress = null;\n        /**\n         * The (optional) progress wave canvas rendering context\n         *\n         * @type {CanvasRenderingContext2D}\n         */\n        this.progressCtx = null;\n        /**\n         * Start of the area the canvas should render, between 0 and 1\n         *\n         * @type {number}\n         */\n        this.start = 0;\n        /**\n         * End of the area the canvas should render, between 0 and 1\n         *\n         * @type {number}\n         */\n        this.end = 1;\n        /**\n         * Unique identifier for this entry\n         *\n         * @type {string}\n         */\n        this.id = getId(\n            typeof this.constructor.name !== 'undefined'\n                ? this.constructor.name.toLowerCase() + '_'\n                : 'canvasentry_'\n        );\n        /**\n         * Canvas 2d context attributes\n         *\n         * @type {object}\n         */\n        this.canvasContextAttributes = {};\n    }\n\n    /**\n     * Store the wave canvas element and create the 2D rendering context\n     *\n     * @param {HTMLCanvasElement} element The wave `canvas` element.\n     */\n    initWave(element) {\n        this.wave = element;\n        this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);\n    }\n\n    /**\n     * Store the progress wave canvas element and create the 2D rendering\n     * context\n     *\n     * @param {HTMLCanvasElement} element The progress wave `canvas` element.\n     */\n    initProgress(element) {\n        this.progress = element;\n        this.progressCtx = this.progress.getContext(\n            '2d',\n            this.canvasContextAttributes\n        );\n    }\n\n    /**\n     * Update the dimensions\n     *\n     * @param {number} elementWidth Width of the entry\n     * @param {number} totalWidth Total width of the multi canvas renderer\n     * @param {number} width The new width of the element\n     * @param {number} height The new height of the element\n     */\n    updateDimensions(elementWidth, totalWidth, width, height) {\n        // where the canvas starts and ends in the waveform, represented as a\n        // decimal between 0 and 1\n        this.start = this.wave.offsetLeft / totalWidth || 0;\n        this.end = this.start + elementWidth / totalWidth;\n\n        // set wave canvas dimensions\n        this.wave.width = width;\n        this.wave.height = height;\n        let elementSize = { width: elementWidth + 'px' };\n        style(this.wave, elementSize);\n\n        if (this.hasProgressCanvas) {\n            // set progress canvas dimensions\n            this.progress.width = width;\n            this.progress.height = height;\n            style(this.progress, elementSize);\n        }\n    }\n\n    /**\n     * Clear the wave and progress rendering contexts\n     */\n    clearWave() {\n        // wave\n        this.waveCtx.clearRect(\n            0,\n            0,\n            this.waveCtx.canvas.width,\n            this.waveCtx.canvas.height\n        );\n\n        // progress\n        if (this.hasProgressCanvas) {\n            this.progressCtx.clearRect(\n                0,\n                0,\n                this.progressCtx.canvas.width,\n                this.progressCtx.canvas.height\n            );\n        }\n    }\n\n    /**\n     * Set the fill styles for wave and progress\n     *\n     * @param {string} waveColor Fill color for the wave canvas\n     * @param {?string} progressColor Fill color for the progress canvas\n     */\n    setFillStyles(waveColor, progressColor) {\n        this.waveCtx.fillStyle = waveColor;\n\n        if (this.hasProgressCanvas) {\n            this.progressCtx.fillStyle = progressColor;\n        }\n    }\n\n    /**\n     * Draw a rectangle for wave and progress\n     *\n     * @param {number} x X start position\n     * @param {number} y Y start position\n     * @param {number} width Width of the rectangle\n     * @param {number} height Height of the rectangle\n     * @param {number} radius Radius of the rectangle\n     */\n    fillRects(x, y, width, height, radius) {\n        this.fillRectToContext(this.waveCtx, x, y, width, height, radius);\n\n        if (this.hasProgressCanvas) {\n            this.fillRectToContext(\n                this.progressCtx,\n                x,\n                y,\n                width,\n                height,\n                radius\n            );\n        }\n    }\n\n    /**\n     * Draw the actual rectangle on a `canvas` element\n     *\n     * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas\n     * @param {number} x X start position\n     * @param {number} y Y start position\n     * @param {number} width Width of the rectangle\n     * @param {number} height Height of the rectangle\n     * @param {number} radius Radius of the rectangle\n     */\n    fillRectToContext(ctx, x, y, width, height, radius) {\n        if (!ctx) {\n            return;\n        }\n\n        if (radius) {\n            this.drawRoundedRect(ctx, x, y, width, height, radius);\n        } else {\n            ctx.fillRect(x, y, width, height);\n        }\n    }\n\n    /**\n     * Draw a rounded rectangle on Canvas\n     *\n     * @param {CanvasRenderingContext2D} ctx Canvas context\n     * @param {number} x X-position of the rectangle\n     * @param {number} y Y-position of the rectangle\n     * @param {number} width Width of the rectangle\n     * @param {number} height Height of the rectangle\n     * @param {number} radius Radius of the rectangle\n     *\n     * @return {void}\n     * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)\n     */\n    drawRoundedRect(ctx, x, y, width, height, radius) {\n        if (height === 0) {\n            return;\n        }\n        // peaks are float values from -1 to 1. Use absolute height values in\n        // order to correctly calculate rounded rectangle coordinates\n        if (height < 0) {\n            height *= -1;\n            y -= height;\n        }\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + width - radius, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n        ctx.lineTo(x + width, y + height - radius);\n        ctx.quadraticCurveTo(\n            x + width,\n            y + height,\n            x + width - radius,\n            y + height\n        );\n        ctx.lineTo(x + radius, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    /**\n     * Render the actual wave and progress lines\n     *\n     * @param {number[]} peaks Array with peaks data\n     * @param {number} absmax Maximum peak value (absolute)\n     * @param {number} halfH Half the height of the waveform\n     * @param {number} offsetY Offset to the top\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that\n     * should be rendered\n     */\n    drawLines(peaks, absmax, halfH, offsetY, start, end) {\n        this.drawLineToContext(\n            this.waveCtx,\n            peaks,\n            absmax,\n            halfH,\n            offsetY,\n            start,\n            end\n        );\n\n        if (this.hasProgressCanvas) {\n            this.drawLineToContext(\n                this.progressCtx,\n                peaks,\n                absmax,\n                halfH,\n                offsetY,\n                start,\n                end\n            );\n        }\n    }\n\n    /**\n     * Render the actual waveform line on a `canvas` element\n     *\n     * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas\n     * @param {number[]} peaks Array with peaks data\n     * @param {number} absmax Maximum peak value (absolute)\n     * @param {number} halfH Half the height of the waveform\n     * @param {number} offsetY Offset to the top\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that\n     * should be rendered\n     */\n    drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {\n        if (!ctx) {\n            return;\n        }\n\n        const length = peaks.length / 2;\n        const first = Math.round(length * this.start);\n\n        // use one more peak value to make sure we join peaks at ends -- unless,\n        // of course, this is the last canvas\n        const last = Math.round(length * this.end) + 1;\n\n        const canvasStart = first;\n        const canvasEnd = last;\n        const scale = this.wave.width / (canvasEnd - canvasStart - 1);\n\n        // optimization\n        const halfOffset = halfH + offsetY;\n        const absmaxHalf = absmax / halfH;\n\n        ctx.beginPath();\n        ctx.moveTo((canvasStart - first) * scale, halfOffset);\n\n        ctx.lineTo(\n            (canvasStart - first) * scale,\n            halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf)\n        );\n\n        let i, peak, h;\n        for (i = canvasStart; i < canvasEnd; i++) {\n            peak = peaks[2 * i] || 0;\n            h = Math.round(peak / absmaxHalf);\n            ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);\n        }\n\n        // draw the bottom edge going backwards, to make a single\n        // closed hull to fill\n        let j = canvasEnd - 1;\n        for (j; j >= canvasStart; j--) {\n            peak = peaks[2 * j + 1] || 0;\n            h = Math.round(peak / absmaxHalf);\n            ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);\n        }\n\n        ctx.lineTo(\n            (canvasStart - first) * scale,\n            halfOffset -\n                Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf)\n        );\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    /**\n     * Destroys this entry\n     */\n    destroy() {\n        this.waveCtx = null;\n        this.wave = null;\n\n        this.progressCtx = null;\n        this.progress = null;\n    }\n\n    /**\n     * Return image data of the wave `canvas` element\n     *\n     * When using a `type` of `'blob'`, this will return a `Promise` that\n     * resolves with a `Blob` instance.\n     *\n     * @param {string} format='image/png' An optional value of a format type.\n     * @param {number} quality=0.92 An optional value between 0 and 1.\n     * @param {string} type='dataURL' Either 'dataURL' or 'blob'.\n     * @return {string|Promise} When using the default `'dataURL'` `type` this\n     * returns a data URL. When using the `'blob'` `type` this returns a\n     * `Promise` that resolves with a `Blob` instance.\n     */\n    getImage(format, quality, type) {\n        if (type === 'blob') {\n            return new Promise(resolve => {\n                this.wave.toBlob(resolve, format, quality);\n            });\n        } else if (type === 'dataURL') {\n            return this.wave.toDataURL(format, quality);\n        }\n    }\n}\n","import * as util from './util';\n\n/**\n * Parent class for renderers\n *\n * @extends {Observer}\n */\nexport default class Drawer extends util.Observer {\n    /**\n     * @param {HTMLElement} container The container node of the wavesurfer instance\n     * @param {WavesurferParams} params The wavesurfer initialisation options\n     */\n    constructor(container, params) {\n        super();\n\n        this.container = container;\n        /**\n         * @type {WavesurferParams}\n         */\n        this.params = params;\n        /**\n         * The width of the renderer\n         * @type {number}\n         */\n        this.width = 0;\n        /**\n         * The height of the renderer\n         * @type {number}\n         */\n        this.height = params.height * this.params.pixelRatio;\n\n        this.lastPos = 0;\n        /**\n         * The `<wave>` element which is added to the container\n         * @type {HTMLElement}\n         */\n        this.wrapper = null;\n    }\n\n    /**\n     * Alias of `util.style`\n     *\n     * @param {HTMLElement} el The element that the styles will be applied to\n     * @param {Object} styles The map of propName: attribute, both are used as-is\n     * @return {HTMLElement} el\n     */\n    style(el, styles) {\n        return util.style(el, styles);\n    }\n\n    /**\n     * Create the wrapper `<wave>` element, style it and set up the events for\n     * interaction\n     */\n    createWrapper() {\n        this.wrapper = this.container.appendChild(\n            document.createElement('wave')\n        );\n\n        this.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: this.params.height + 'px'\n        });\n\n        if (this.params.fillParent || this.params.scrollParent) {\n            this.style(this.wrapper, {\n                width: '100%',\n                overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',\n                overflowY: 'hidden'\n            });\n        }\n\n        this.setupWrapperEvents();\n    }\n\n    /**\n     * Handle click event\n     *\n     * @param {Event} e Click event\n     * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`\n     * @return {number} Playback position from 0 to 1\n     */\n    handleEvent(e, noPrevent) {\n        !noPrevent && e.preventDefault();\n\n        const clientX = e.targetTouches\n            ? e.targetTouches[0].clientX\n            : e.clientX;\n        const bbox = this.wrapper.getBoundingClientRect();\n\n        const nominalWidth = this.width;\n        const parentWidth = this.getWidth();\n\n        let progress;\n        if (!this.params.fillParent && nominalWidth < parentWidth) {\n            progress =\n                (this.params.rtl ? bbox.right - clientX : clientX - bbox.left) *\n                    (this.params.pixelRatio / nominalWidth) || 0;\n\n            if (progress > 1) {\n                progress = 1;\n            }\n        } else {\n            progress =\n                ((this.params.rtl\n                    ? bbox.right - clientX\n                    : clientX - bbox.left) +\n                    this.wrapper.scrollLeft) /\n                    this.wrapper.scrollWidth || 0;\n        }\n\n        return progress;\n    }\n\n    setupWrapperEvents() {\n        this.wrapper.addEventListener('click', e => {\n            const scrollbarHeight =\n                this.wrapper.offsetHeight - this.wrapper.clientHeight;\n            if (scrollbarHeight !== 0) {\n                // scrollbar is visible.  Check if click was on it\n                const bbox = this.wrapper.getBoundingClientRect();\n                if (e.clientY >= bbox.bottom - scrollbarHeight) {\n                    // ignore mousedown as it was on the scrollbar\n                    return;\n                }\n            }\n\n            if (this.params.interact) {\n                this.fireEvent('click', e, this.handleEvent(e));\n            }\n        });\n\n        this.wrapper.addEventListener('dblclick', e => {\n            if (this.params.interact) {\n                this.fireEvent('dblclick', e, this.handleEvent(e));\n            }\n        });\n\n        this.wrapper.addEventListener('scroll', e =>\n            this.fireEvent('scroll', e)\n        );\n    }\n\n    /**\n     * Draw peaks on the canvas\n     *\n     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n     * for split channel rendering\n     * @param {number} length The width of the area that should be drawn\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that should be\n     * rendered\n     */\n    drawPeaks(peaks, length, start, end) {\n        if (!this.setWidth(length)) {\n            this.clearWave();\n        }\n\n        this.params.barWidth\n            ? this.drawBars(peaks, 0, start, end)\n            : this.drawWave(peaks, 0, start, end);\n    }\n\n    /**\n     * Scroll to the beginning\n     */\n    resetScroll() {\n        if (this.wrapper !== null) {\n            this.wrapper.scrollLeft = 0;\n        }\n    }\n\n    /**\n     * Recenter the view-port at a certain percent of the waveform\n     *\n     * @param {number} percent Value from 0 to 1 on the waveform\n     */\n    recenter(percent) {\n        const position = this.wrapper.scrollWidth * percent;\n        this.recenterOnPosition(position, true);\n    }\n\n    /**\n     * Recenter the view-port on a position, either scroll there immediately or\n     * in steps of 5 pixels\n     *\n     * @param {number} position X-offset in pixels\n     * @param {boolean} immediate Set to true to immediately scroll somewhere\n     */\n    recenterOnPosition(position, immediate) {\n        const scrollLeft = this.wrapper.scrollLeft;\n        const half = ~~(this.wrapper.clientWidth / 2);\n        const maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n        let target = position - half;\n        let offset = target - scrollLeft;\n\n        if (maxScroll == 0) {\n            // no need to continue if scrollbar is not there\n            return;\n        }\n\n        // if the cursor is currently visible...\n        if (!immediate && -half <= offset && offset < half) {\n            // set rate at which waveform is centered\n            let rate = this.params.autoCenterRate;\n\n            // make rate depend on width of view and length of waveform\n            rate /= half;\n            rate *= maxScroll;\n\n            offset = Math.max(-rate, Math.min(rate, offset));\n            target = scrollLeft + offset;\n        }\n\n        // limit target to valid range (0 to maxScroll)\n        target = Math.max(0, Math.min(maxScroll, target));\n        // no use attempting to scroll if we're not moving\n        if (target != scrollLeft) {\n            this.wrapper.scrollLeft = target;\n        }\n    }\n\n    /**\n     * Get the current scroll position in pixels\n     *\n     * @return {number} Horizontal scroll position in pixels\n     */\n    getScrollX() {\n        let x = 0;\n        if (this.wrapper) {\n            const pixelRatio = this.params.pixelRatio;\n            x = Math.round(this.wrapper.scrollLeft * pixelRatio);\n\n            // In cases of elastic scroll (safari with mouse wheel) you can\n            // scroll beyond the limits of the container\n            // Calculate and floor the scrollable extent to make sure an out\n            // of bounds value is not returned\n            // Ticket #1312\n            if (this.params.scrollParent) {\n                const maxScroll = ~~(\n                    this.wrapper.scrollWidth * pixelRatio -\n                    this.getWidth()\n                );\n                x = Math.min(maxScroll, Math.max(0, x));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * Get the width of the container\n     *\n     * @return {number} The width of the container\n     */\n    getWidth() {\n        return Math.round(this.container.clientWidth * this.params.pixelRatio);\n    }\n\n    /**\n     * Set the width of the container\n     *\n     * @param {number} width The new width of the container\n     * @return {boolean} Whether the width of the container was updated or not\n     */\n    setWidth(width) {\n        if (this.width == width) {\n            return false;\n        }\n\n        this.width = width;\n\n        if (this.params.fillParent || this.params.scrollParent) {\n            this.style(this.wrapper, {\n                width: ''\n            });\n        } else {\n            this.style(this.wrapper, {\n                width: ~~(this.width / this.params.pixelRatio) + 'px'\n            });\n        }\n\n        this.updateSize();\n        return true;\n    }\n\n    /**\n     * Set the height of the container\n     *\n     * @param {number} height The new height of the container.\n     * @return {boolean} Whether the height of the container was updated or not\n     */\n    setHeight(height) {\n        if (height == this.height) {\n            return false;\n        }\n        this.height = height;\n\n        this.style(this.wrapper, {\n            height: ~~(this.height / this.params.pixelRatio) + 'px'\n        });\n\n        this.updateSize();\n        return true;\n    }\n\n    /**\n     * Called by wavesurfer when progress should be rendered\n     *\n     * @param {number} progress From 0 to 1\n     */\n    progress(progress) {\n        const minPxDelta = 1 / this.params.pixelRatio;\n        const pos = Math.round(progress * this.width) * minPxDelta;\n\n        if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {\n            this.lastPos = pos;\n\n            if (this.params.scrollParent && this.params.autoCenter) {\n                const newPos = ~~(this.wrapper.scrollWidth * progress);\n                this.recenterOnPosition(\n                    newPos,\n                    this.params.autoCenterImmediately\n                );\n            }\n\n            this.updateProgress(pos);\n        }\n    }\n\n    /**\n     * This is called when wavesurfer is destroyed\n     */\n    destroy() {\n        this.unAll();\n        if (this.wrapper) {\n            if (this.wrapper.parentNode == this.container) {\n                this.container.removeChild(this.wrapper);\n            }\n            this.wrapper = null;\n        }\n    }\n\n    /* Renderer-specific methods */\n\n    /**\n     * Called after cursor related params have changed.\n     *\n     * @abstract\n     */\n    updateCursor() {}\n\n    /**\n     * Called when the size of the container changes so the renderer can adjust\n     *\n     * @abstract\n     */\n    updateSize() {}\n\n    /**\n     * Draw a waveform with bars\n     *\n     * @abstract\n     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel\n     * rendering\n     * @param {number} channelIndex The index of the current channel. Normally\n     * should be 0\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that should be\n     * rendered\n     */\n    drawBars(peaks, channelIndex, start, end) {}\n\n    /**\n     * Draw a waveform\n     *\n     * @abstract\n     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel\n     * rendering\n     * @param {number} channelIndex The index of the current channel. Normally\n     * should be 0\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that should be\n     * rendered\n     */\n    drawWave(peaks, channelIndex, start, end) {}\n\n    /**\n     * Clear the waveform\n     *\n     * @abstract\n     */\n    clearWave() {}\n\n    /**\n     * Render the new progress\n     *\n     * @abstract\n     * @param {number} position X-Offset of progress position in pixels\n     */\n    updateProgress(position) {}\n}\n","import Drawer from './drawer';\nimport * as util from './util';\nimport CanvasEntry from './drawer.canvasentry';\n\n/**\n * MultiCanvas renderer for wavesurfer. Is currently the default and sole\n * builtin renderer.\n *\n * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending\n * on the zoom level.\n */\nexport default class MultiCanvas extends Drawer {\n    /**\n     * @param {HTMLElement} container The container node of the wavesurfer instance\n     * @param {WavesurferParams} params The wavesurfer initialisation options\n     */\n    constructor(container, params) {\n        super(container, params);\n\n        /**\n         * @type {number}\n         */\n        this.maxCanvasWidth = params.maxCanvasWidth;\n\n        /**\n         * @type {number}\n         */\n        this.maxCanvasElementWidth = Math.round(\n            params.maxCanvasWidth / params.pixelRatio\n        );\n\n        /**\n         * Whether or not the progress wave is rendered. If the `waveColor`\n         * and `progressColor` are the same color it is not.\n         *\n         * @type {boolean}\n         */\n        this.hasProgressCanvas = params.waveColor != params.progressColor;\n\n        /**\n         * @type {number}\n         */\n        this.halfPixel = 0.5 / params.pixelRatio;\n\n        /**\n         * List of `CanvasEntry` instances.\n         *\n         * @type {Array}\n         */\n        this.canvases = [];\n\n        /**\n         * @type {HTMLElement}\n         */\n        this.progressWave = null;\n\n        /**\n         * Class used to generate entries.\n         *\n         * @type {function}\n         */\n        this.EntryClass = CanvasEntry;\n\n        /**\n         * Canvas 2d context attributes.\n         *\n         * @type {object}\n         */\n        this.canvasContextAttributes = params.drawingContextAttributes;\n\n        /**\n         * Overlap added between entries to prevent vertical white stripes\n         * between `canvas` elements.\n         *\n         * @type {number}\n         */\n        this.overlap = 2 * Math.ceil(params.pixelRatio / 2);\n\n        /**\n         * The radius of the wave bars. Makes bars rounded\n         *\n         * @type {number}\n         */\n        this.barRadius = params.barRadius || 0;\n    }\n\n    /**\n     * Initialize the drawer\n     */\n    init() {\n        this.createWrapper();\n        this.createElements();\n    }\n\n    /**\n     * Create the canvas elements and style them\n     *\n     */\n    createElements() {\n        this.progressWave = this.wrapper.appendChild(\n            this.style(document.createElement('wave'), {\n                position: 'absolute',\n                zIndex: 3,\n                left: 0,\n                top: 0,\n                bottom: 0,\n                overflow: 'hidden',\n                width: '0',\n                display: 'none',\n                boxSizing: 'border-box',\n                borderRightStyle: 'solid',\n                pointerEvents: 'none'\n            })\n        );\n\n        this.addCanvas();\n        this.updateCursor();\n    }\n\n    /**\n     * Update cursor style\n     */\n    updateCursor() {\n        this.style(this.progressWave, {\n            borderRightWidth: this.params.cursorWidth + 'px',\n            borderRightColor: this.params.cursorColor\n        });\n    }\n\n    /**\n     * Adjust to the updated size by adding or removing canvases\n     */\n    updateSize() {\n        const totalWidth = Math.round(this.width / this.params.pixelRatio);\n        const requiredCanvases = Math.ceil(\n            totalWidth / (this.maxCanvasElementWidth + this.overlap)\n        );\n\n        // add required canvases\n        while (this.canvases.length < requiredCanvases) {\n            this.addCanvas();\n        }\n\n        // remove older existing canvases, if any\n        while (this.canvases.length > requiredCanvases) {\n            this.removeCanvas();\n        }\n\n        let canvasWidth = this.maxCanvasWidth + this.overlap;\n        const lastCanvas = this.canvases.length - 1;\n        this.canvases.forEach((entry, i) => {\n            if (i == lastCanvas) {\n                canvasWidth = this.width - this.maxCanvasWidth * lastCanvas;\n            }\n            this.updateDimensions(entry, canvasWidth, this.height);\n\n            entry.clearWave();\n        });\n\n        this.style(this.progressWave, { width: totalWidth + \"px\" });\n        this.style(this.progressWave, { \"clip-path\": this.makeInset(totalWidth), \"-webkit-clip-path\": this.makeInset(totalWidth)});\n    }\n\n    /**\n     * Add a canvas to the canvas list\n     *\n     */\n    addCanvas() {\n        const entry = new this.EntryClass();\n        entry.canvasContextAttributes = this.canvasContextAttributes;\n        entry.hasProgressCanvas = this.hasProgressCanvas;\n        entry.halfPixel = this.halfPixel;\n        const leftOffset = this.maxCanvasElementWidth * this.canvases.length;\n\n        // wave\n        entry.initWave(\n            this.wrapper.appendChild(\n                this.style(document.createElement('canvas'), {\n                    position: 'absolute',\n                    zIndex: 2,\n                    left: leftOffset + 'px',\n                    top: 0,\n                    bottom: 0,\n                    height: '100%',\n                    pointerEvents: 'none'\n                })\n            )\n        );\n\n        // progress\n        if (this.hasProgressCanvas) {\n            entry.initProgress(\n                this.progressWave.appendChild(\n                    this.style(document.createElement('canvas'), {\n                        position: 'absolute',\n                        left: leftOffset + 'px',\n                        top: 0,\n                        bottom: 0,\n                        height: '100%'\n                    })\n                )\n            );\n        }\n\n        this.canvases.push(entry);\n    }\n\n    /**\n     * Pop single canvas from the list\n     *\n     */\n    removeCanvas() {\n        let lastEntry = this.canvases[this.canvases.length - 1];\n\n        // wave\n        lastEntry.wave.parentElement.removeChild(lastEntry.wave);\n\n        // progress\n        if (this.hasProgressCanvas) {\n            lastEntry.progress.parentElement.removeChild(lastEntry.progress);\n        }\n\n        // cleanup\n        if (lastEntry) {\n            lastEntry.destroy();\n            lastEntry = null;\n        }\n\n        this.canvases.pop();\n    }\n\n    /**\n     * Update the dimensions of a canvas element\n     *\n     * @param {CanvasEntry} entry Target entry\n     * @param {number} width The new width of the element\n     * @param {number} height The new height of the element\n     */\n    updateDimensions(entry, width, height) {\n        const elementWidth = Math.round(width / this.params.pixelRatio);\n        const totalWidth = Math.round(this.width / this.params.pixelRatio);\n\n        // update canvas dimensions\n        entry.updateDimensions(elementWidth, totalWidth, width, height);\n\n        // style element\n        this.style(this.progressWave, { display: 'block' });\n    }\n\n    /**\n     * Clear the whole multi-canvas\n     */\n    clearWave() {\n        util.frame(() => {\n            this.canvases.forEach(entry => entry.clearWave());\n        })();\n    }\n\n    /**\n     * Draw a waveform with bars\n     *\n     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n     * for split channel rendering\n     * @param {number} channelIndex The index of the current channel. Normally\n     * should be 0. Must be an integer.\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that should be\n     * rendered\n     * @returns {void}\n     */\n    drawBars(peaks, channelIndex, start, end) {\n        return this.prepareDraw(\n            peaks,\n            channelIndex,\n            start,\n            end,\n            ({ absmax, hasMinVals, height, offsetY, halfH, peaks }) => {\n                // if drawBars was called within ws.empty we don't pass a start and\n                // don't want anything to happen\n                if (start === undefined) {\n                    return;\n                }\n                // Skip every other value if there are negatives.\n                const peakIndexScale = hasMinVals ? 2 : 1;\n                const length = peaks.length / peakIndexScale;\n                const bar = this.params.barWidth * this.params.pixelRatio;\n                const gap =\n                    this.params.barGap === null\n                        ? Math.max(this.params.pixelRatio, ~~(bar / 2))\n                        : Math.max(\n                            this.params.pixelRatio,\n                            this.params.barGap * this.params.pixelRatio\n                        );\n                const step = bar + gap;\n\n                const scale = length / this.width;\n                const first = start;\n                const last = end;\n                let i = first;\n                let halfHmod = this.params.reflection ? 1 : 2;\n\n                for (i; i < last; i += step) {\n                    const peak =\n                        peaks[Math.floor(i * scale * peakIndexScale)] || 0;\n                    let h;\n\n                    if (this.params.reflection){\n                        h = Math.round((peak / absmax) * halfH);\n\n                    } else {\n                        h = Math.abs(Math.round((peak / absmax) * halfH));\n                    }\n\n                    /* in case of silences, allow the user to specify that we\n                     * always draw *something* (normally a 1px high bar) */\n                    if (h == 0 && this.params.barMinHeight)\n                        h = this.params.barMinHeight;\n\n\n                    this.fillRect(\n                        i + this.halfPixel,\n                        halfH * halfHmod - h * halfHmod + offsetY,\n                        bar + this.halfPixel,\n                        h * 2 * halfHmod,\n                        this.barRadius\n                    );\n                }\n            }\n        );\n    }\n\n    /**\n     * Draw a waveform\n     *\n     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n     * for split channel rendering\n     * @param {number} channelIndex The index of the current channel. Normally\n     * should be 0\n     * @param {number?} start The x-offset of the beginning of the area that\n     * should be rendered (If this isn't set only a flat line is rendered)\n     * @param {number?} end The x-offset of the end of the area that should be\n     * rendered\n     * @returns {void}\n     */\n    drawWave(peaks, channelIndex, start, end) {\n        return this.prepareDraw(\n            peaks,\n            channelIndex,\n            start,\n            end,\n            ({ absmax, hasMinVals, height, offsetY, halfH, peaks, channelIndex }) => {\n                if (!hasMinVals) {\n                    const reflectedPeaks = [];\n                    const len = peaks.length;\n                    let i = 0;\n                    for (i; i < len; i++) {\n                        reflectedPeaks[2 * i] = peaks[i];\n                        reflectedPeaks[2 * i + 1] = -peaks[i];\n                    }\n                    peaks = reflectedPeaks;\n                }\n\n                // if drawWave was called within ws.empty we don't pass a start and\n                // end and simply want a flat line\n                if (start !== undefined) {\n                    this.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);\n                }\n\n                // always draw a median line\n                this.fillRect(\n                    0,\n                    halfH + offsetY - this.halfPixel,\n                    this.width,\n                    this.halfPixel,\n                    this.barRadius\n                );\n            }\n        );\n    }\n\n    /**\n     * Tell the canvas entries to render their portion of the waveform\n     *\n     * @param {number[]} peaks Peaks data\n     * @param {number} absmax Maximum peak value (absolute)\n     * @param {number} halfH Half the height of the waveform\n     * @param {number} offsetY Offset to the top\n     * @param {number} start The x-offset of the beginning of the area that\n     * should be rendered\n     * @param {number} end The x-offset of the end of the area that\n     * should be rendered\n     * @param {channelIndex} channelIndex The channel index of the line drawn\n     */\n    drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {\n        const { waveColor, progressColor } = this.params.splitChannelsOptions.channelColors[channelIndex] || {};\n        this.canvases.forEach((entry, i) => {\n            this.setFillStyles(entry, waveColor, progressColor);\n            entry.drawLines(peaks, absmax, halfH, offsetY, start, end);\n        });\n    }\n\n    /**\n     * Draw a rectangle on the multi-canvas\n     *\n     * @param {number} x X-position of the rectangle\n     * @param {number} y Y-position of the rectangle\n     * @param {number} width Width of the rectangle\n     * @param {number} height Height of the rectangle\n     * @param {number} radius Radius of the rectangle\n     */\n    fillRect(x, y, width, height, radius) {\n        const startCanvas = Math.floor(x / this.maxCanvasWidth);\n        const endCanvas = Math.min(\n            Math.ceil((x + width) / this.maxCanvasWidth) + 1,\n            this.canvases.length\n        );\n        let i = startCanvas;\n        for (i; i < endCanvas; i++) {\n            const entry = this.canvases[i];\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(\n                    x + width,\n                    i * this.maxCanvasWidth + entry.wave.width\n                ),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                this.setFillStyles(entry);\n\n                entry.fillRects(\n                    intersection.x1 - leftOffset,\n                    intersection.y1,\n                    intersection.x2 - intersection.x1,\n                    intersection.y2 - intersection.y1,\n                    radius\n                );\n            }\n        }\n    }\n\n    /**\n     * Returns whether to hide the channel from being drawn based on params.\n     *\n     * @param {number} channelIndex The index of the current channel.\n     * @returns {bool} True to hide the channel, false to draw.\n     */\n    hideChannel(channelIndex) {\n        return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);\n    }\n\n    /**\n     * Performs preparation tasks and calculations which are shared by `drawBars`\n     * and `drawWave`\n     *\n     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for\n     * split channel rendering\n     * @param {number} channelIndex The index of the current channel. Normally\n     * should be 0\n     * @param {number?} start The x-offset of the beginning of the area that\n     * should be rendered. If this isn't set only a flat line is rendered\n     * @param {number?} end The x-offset of the end of the area that should be\n     * rendered\n     * @param {function} fn The render function to call, e.g. `drawWave`\n     * @param {number} drawIndex The index of the current channel after filtering.\n     * @returns {void}\n     */\n    prepareDraw(peaks, channelIndex, start, end, fn, drawIndex) {\n        return util.frame(() => {\n            // Split channels and call this function with the channelIndex set\n            if (peaks[0] instanceof Array) {\n                const channels = peaks;\n\n                if (this.params.splitChannels) {\n                    const filteredChannels =  channels.filter((c, i) => !this.hideChannel(i));\n                    if (!this.params.splitChannelsOptions.overlay) {\n                        this.setHeight(\n                            Math.max(filteredChannels.length, 1) *\n                                this.params.height *\n                                this.params.pixelRatio\n                        );\n                    }\n\n                    return channels.forEach((channelPeaks, i) =>\n                        this.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks))\n                    );\n                }\n                peaks = channels[0];\n            }\n\n            // Return and do not draw channel peaks if hidden.\n            if (this.hideChannel(channelIndex)) {\n                return;\n            }\n\n            // calculate maximum modulation value, either from the barHeight\n            // parameter or if normalize=true from the largest value in the peak\n            // set\n            let absmax = 1 / this.params.barHeight;\n            if (this.params.normalize) {\n                const max = util.max(peaks);\n                const min = util.min(peaks);\n                absmax = -min > max ? -min : max;\n            }\n\n            // Bar wave draws the bottom only as a reflection of the top,\n            // so we don't need negative values\n            const hasMinVals = [].some.call(peaks, val => val < 0);\n            const height = this.params.height * this.params.pixelRatio;\n            const offsetY = height * drawIndex || 0;\n            const halfH = height / 2;\n\n            return fn({\n                absmax: absmax,\n                hasMinVals: hasMinVals,\n                height: height,\n                offsetY: offsetY,\n                halfH: halfH,\n                peaks: peaks,\n                channelIndex: channelIndex,\n            });\n        })();\n    }\n\n    /**\n     * Set the fill styles for a certain entry (wave and progress)\n     *\n     * @param {CanvasEntry} entry Target entry\n     * @param {string} waveColor Wave color to draw this entry\n     * @param {string} progressColor Progress color to draw this entry\n     */\n    setFillStyles(entry, waveColor = this.params.waveColor, progressColor = this.params.progressColor) {\n        entry.setFillStyles(waveColor, progressColor);\n    }\n\n    /**\n     * Return image data of the multi-canvas\n     *\n     * When using a `type` of `'blob'`, this will return a `Promise`.\n     *\n     * @param {string} format='image/png' An optional value of a format type.\n     * @param {number} quality=0.92 An optional value between 0 and 1.\n     * @param {string} type='dataURL' Either 'dataURL' or 'blob'.\n     * @return {string|string[]|Promise} When using the default `'dataURL'`\n     * `type` this returns a single data URL or an array of data URLs,\n     * one for each canvas. When using the `'blob'` `type` this returns a\n     * `Promise` that resolves with an array of `Blob` instances, one for each\n     * canvas.\n     */\n    getImage(format, quality, type) {\n        if (type === 'blob') {\n            return Promise.all(\n                this.canvases.map(entry => {\n                    return entry.getImage(format, quality, type);\n                })\n            );\n        } else if (type === 'dataURL') {\n            let images = this.canvases.map(entry =>\n                entry.getImage(format, quality, type)\n            );\n            return images.length > 1 ? images : images[0];\n        }\n    }\n\n    /**\n     * build a css inset string for masking off portions of the progessWave\n     *\n     * In order to avoid browser layout passes, we leave our progress wave at full width\n     * but mask a portion of it off using the `clip-path` CSS property.\n     *\n     * @param {number} rightInset=number of pixels to clip off the right\n     * @return {string} css\n     */\n    makeInset(rightInset) {\n        return `inset(0px ${rightInset}px 0px 0px)`;\n    }\n\n    /**\n     * Render the new progress\n     *\n     * @param {number} position X-offset of progress position in pixels\n     */\n    updateProgress(position) {\n        let actualWidth = this.width / this.params.pixelRatio;\n\n        this.style(this.progressWave, { 'clip-path': this.makeInset(actualWidth - position), '-webkit-clip-path': this.makeInset(actualWidth - position)});\n    }\n}\n","import Observer from './observer';\n\n/**\n * Perform an ajax request using `XMLHttpRequest`.\n *\n * @deprecated Use `util.fetchFile` instead.\n *\n * @param {Object} options AJAX options to use. See example below for options.\n * @returns {Observer} Observer instance\n * @example\n * // default options\n * let options = {\n *     method: 'GET',\n *     url: undefined,\n *     responseType: 'json',\n *     xhr: {}\n * };\n *\n * // override default options\n * options.url = '../media/demo.wav';\n * options.responseType = 'arraybuffer';\n * options.xhr = {\n *     requestHeaders: [\n *         {\n *             key: 'Authorization',\n *             value: 'my-token'\n *         }\n *     ],\n *     withCredentials: true\n * };\n *\n * // make ajax call\n * let ajaxCall = util.ajax(options);\n * ajaxCall.on('progress', e => {\n *     console.log('progress', e);\n * });\n * ajaxCall.on('success', (data, e) => {\n *     console.log('success!', data);\n * });\n * ajaxCall.on('error', e => {\n *     console.warn('ajax error: ' + e.target.statusText);\n * });\n */\nexport default function ajax(options) {\n    const instance = new Observer();\n    const xhr = new XMLHttpRequest();\n    let fired100 = false;\n    xhr.open(options.method || 'GET', options.url, true);\n    xhr.responseType = options.responseType || 'json';\n\n    if (options.xhr) {\n        if (options.xhr.requestHeaders) {\n            // add custom request headers\n            options.xhr.requestHeaders.forEach(header => {\n                xhr.setRequestHeader(header.key, header.value);\n            });\n        }\n        if (options.xhr.withCredentials) {\n            // use credentials\n            xhr.withCredentials = true;\n        }\n    }\n\n    xhr.addEventListener('progress', e => {\n        instance.fireEvent('progress', e);\n        if (e.lengthComputable && e.loaded == e.total) {\n            fired100 = true;\n        }\n    });\n    xhr.addEventListener('load', e => {\n        if (!fired100) {\n            instance.fireEvent('progress', e);\n        }\n        instance.fireEvent('load', e);\n        if (200 == xhr.status || 206 == xhr.status) {\n            instance.fireEvent('success', xhr.response, e);\n        } else {\n            instance.fireEvent('error', e);\n        }\n    });\n    xhr.addEventListener('error', e => instance.fireEvent('error', e));\n    xhr.send();\n    instance.xhr = xhr;\n    return instance;\n}\n","/* eslint no-console: [\"error\", { allow: [\"warn\"] }] */\n/**\n * Extend an object shallowly with others\n *\n * @param {Object} dest The target object\n * @param {Object[]} sources The objects to use for extending\n *\n * @return {Object} Merged object\n * @deprecated since version 3.3.0\n */\nexport default function extend(dest, ...sources) {\n    console.warn('util.extend is deprecated; use Object.assign instead');\n    sources.forEach(source => {\n        Object.keys(source).forEach(key => {\n            dest[key] = source[key];\n        });\n    });\n    return dest;\n}\n","/**\n * @since 3.0.0\n */\n\nimport Observer from './observer';\n\nclass ProgressHandler {\n    /**\n     * Instantiate ProgressHandler\n     *\n     * @param {Observer} instance The `fetchFile` observer instance.\n     * @param {Number} contentLength Content length.\n     * @param {Response} response Response object.\n     */\n    constructor(instance, contentLength, response) {\n        this.instance = instance;\n        this.instance._reader = response.body.getReader();\n\n        this.total = parseInt(contentLength, 10);\n        this.loaded = 0;\n    }\n\n    /**\n     * A method that is called once, immediately after the `ReadableStream``\n     * is constructed.\n     *\n     * @param {ReadableStreamDefaultController} controller Controller instance\n     *     used to control the stream.\n     */\n    start(controller) {\n        const read = () => {\n            // instance._reader.read() returns a promise that resolves\n            // when a value has been received\n            this.instance._reader\n                .read()\n                .then(({ done, value }) => {\n                    // result objects contain two properties:\n                    // done  - true if the stream has already given you all its data.\n                    // value - some data. Always undefined when done is true.\n                    if (done) {\n                        // ensure onProgress called when content-length=0\n                        if (this.total === 0) {\n                            this.instance.onProgress.call(this.instance, {\n                                loaded: this.loaded,\n                                total: this.total,\n                                lengthComputable: false\n                            });\n                        }\n                        // no more data needs to be consumed, close the stream\n                        controller.close();\n                        return;\n                    }\n\n                    this.loaded += value.byteLength;\n                    this.instance.onProgress.call(this.instance, {\n                        loaded: this.loaded,\n                        total: this.total,\n                        lengthComputable: !(this.total === 0)\n                    });\n                    // enqueue the next data chunk into our target stream\n                    controller.enqueue(value);\n                    read();\n                })\n                .catch(error => {\n                    controller.error(error);\n                });\n        };\n\n        read();\n    }\n}\n\n/**\n * Load a file using `fetch`.\n *\n * @param {object} options Request options to use. See example below.\n * @returns {Observer} Observer instance\n * @example\n * // default options\n * let options = {\n *     url: undefined,\n *     method: 'GET',\n *     mode: 'cors',\n *     credentials: 'same-origin',\n *     cache: 'default',\n *     responseType: 'json',\n *     requestHeaders: [],\n *     redirect: 'follow',\n *     referrer: 'client'\n * };\n *\n * // override some options\n * options.url = '../media/demo.wav';\n\n * // available types: 'arraybuffer', 'blob', 'json' or 'text'\n * options.responseType = 'arraybuffer';\n *\n * // make fetch call\n * let request = util.fetchFile(options);\n *\n * // listen for events\n * request.on('progress', e => {\n *     console.log('progress', e);\n * });\n *\n * request.on('success', data => {\n *     console.log('success!', data);\n * });\n *\n * request.on('error', e => {\n *     console.warn('fetchFile error: ', e);\n * });\n */\nexport default function fetchFile(options) {\n    if (!options) {\n        throw new Error('fetch options missing');\n    } else if (!options.url) {\n        throw new Error('fetch url missing');\n    }\n    const instance = new Observer();\n    const fetchHeaders = new Headers();\n    const fetchRequest = new Request(options.url);\n\n    // add ability to abort\n    instance.controller = new AbortController();\n\n    // check if headers have to be added\n    if (options && options.requestHeaders) {\n        // add custom request headers\n        options.requestHeaders.forEach(header => {\n            fetchHeaders.append(header.key, header.value);\n        });\n    }\n\n    // parse fetch options\n    const responseType = options.responseType || 'json';\n    const fetchOptions = {\n        method: options.method || 'GET',\n        headers: fetchHeaders,\n        mode: options.mode || 'cors',\n        credentials: options.credentials || 'same-origin',\n        cache: options.cache || 'default',\n        redirect: options.redirect || 'follow',\n        referrer: options.referrer || 'client',\n        signal: instance.controller.signal\n    };\n\n    fetch(fetchRequest, fetchOptions)\n        .then(response => {\n            // store response reference\n            instance.response = response;\n\n            let progressAvailable = true;\n            if (\n                !response.body ||\n                document.documentMode ||\n                /Edge/.test(navigator.userAgent)\n            ) {\n                // ReadableStream is not yet supported in this browser\n                // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n                progressAvailable = false;\n            }\n\n            // Server must send CORS header \"Access-Control-Expose-Headers: content-length\"\n            const contentLength = response.headers.get('content-length');\n            if (contentLength === null) {\n                // Content-Length server response header missing.\n                // Don't evaluate download progress if we can't compare against a total size\n                // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers\n                progressAvailable = false;\n            }\n\n            if (!progressAvailable) {\n                // not able to check download progress so skip it\n                return response;\n            }\n\n            // fire progress event when during load\n            instance.onProgress = e => {\n                instance.fireEvent('progress', e);\n            };\n\n            return new Response(\n                new ReadableStream(\n                    new ProgressHandler(instance, contentLength, response)\n                ),\n                fetchOptions\n            );\n        })\n        .then(response => {\n            let errMsg;\n            if (response.ok) {\n                switch (responseType) {\n                    case 'arraybuffer':\n                        return response.arrayBuffer();\n\n                    case 'json':\n                        return response.json();\n\n                    case 'blob':\n                        return response.blob();\n\n                    case 'text':\n                        return response.text();\n\n                    default:\n                        errMsg = 'Unknown responseType: ' + responseType;\n                        break;\n                }\n            }\n            if (!errMsg) {\n                errMsg = 'HTTP error status: ' + response.status;\n            }\n            throw new Error(errMsg);\n        })\n        .then(response => {\n            instance.fireEvent('success', response);\n        })\n        .catch(error => {\n            instance.fireEvent('error', error);\n        });\n\n    // return the fetch request\n    instance.fetchRequest = fetchRequest;\n    return instance;\n}\n","import reqAnimationFrame from './request-animation-frame';\n\n/**\n * Create a function which will be called at the next requestAnimationFrame\n * cycle\n *\n * @param {function} func The function to call\n *\n * @return {func} The function wrapped within a requestAnimationFrame\n */\nexport default function frame(func) {\n    return (...args) => reqAnimationFrame(() => func(...args));\n}\n","/**\n * Get a random prefixed ID\n *\n * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.\n * @returns {String} Random prefixed ID\n * @example\n * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'\n *\n * let prefix = 'foo-';\n * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'\n */\nexport default function getId(prefix) {\n    if (prefix === undefined) {\n        prefix = 'wavesurfer_';\n    }\n    return (\n        prefix +\n        Math.random()\n            .toString(32)\n            .substring(2)\n    );\n}\n","export { default as ajax } from './ajax';\nexport { default as getId } from './get-id';\nexport { default as max } from './max';\nexport { default as min } from './min';\nexport { default as Observer } from './observer';\nexport { default as extend } from './extend';\nexport { default as style } from './style';\nexport { default as requestAnimationFrame } from './request-animation-frame';\nexport { default as frame } from './frame';\nexport { default as debounce } from 'debounce';\nexport { default as preventClick } from './prevent-click';\nexport { default as fetchFile } from './fetch';\n","/**\n * Get the largest value\n *\n * @param   {Array} values Array of numbers\n * @returns {Number} Largest number found\n * @example console.log(max([1, 2, 3])); // logs 3\n */\nexport default function max(values) {\n    let largest = -Infinity;\n    Object.keys(values).forEach(i => {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    });\n    return largest;\n}\n","/**\n * Get the smallest value\n *\n * @param   {Array} values Array of numbers\n * @returns {Number} Smallest number found\n * @example console.log(min([1, 2, 3])); // logs 1\n */\nexport default function min(values) {\n    let smallest = Number(Infinity);\n    Object.keys(values).forEach(i => {\n        if (values[i] < smallest) {\n            smallest = values[i];\n        }\n    });\n    return smallest;\n}\n","/**\n * @typedef {Object} ListenerDescriptor\n * @property {string} name The name of the event\n * @property {function} callback The callback\n * @property {function} un The function to call to remove the listener\n */\n\n/**\n * Observer class\n */\nexport default class Observer {\n    /**\n     * Instantiate Observer\n     */\n    constructor() {\n        /**\n         * @private\n         * @todo Initialise the handlers here already and remove the conditional\n         * assignment in `on()`\n         */\n        this._disabledEventEmissions = [];\n        this.handlers = null;\n    }\n    /**\n     * Attach a handler function for an event.\n     *\n     * @param {string} event Name of the event to listen to\n     * @param {function} fn The callback to trigger when the event is fired\n     * @return {ListenerDescriptor} The event descriptor\n     */\n    on(event, fn) {\n        if (!this.handlers) {\n            this.handlers = {};\n        }\n\n        let handlers = this.handlers[event];\n        if (!handlers) {\n            handlers = this.handlers[event] = [];\n        }\n        handlers.push(fn);\n\n        // Return an event descriptor\n        return {\n            name: event,\n            callback: fn,\n            un: (e, fn) => this.un(e, fn)\n        };\n    }\n\n    /**\n     * Remove an event handler.\n     *\n     * @param {string} event Name of the event the listener that should be\n     * removed listens to\n     * @param {function} fn The callback that should be removed\n     */\n    un(event, fn) {\n        if (!this.handlers) {\n            return;\n        }\n\n        const handlers = this.handlers[event];\n        let i;\n        if (handlers) {\n            if (fn) {\n                for (i = handlers.length - 1; i >= 0; i--) {\n                    if (handlers[i] == fn) {\n                        handlers.splice(i, 1);\n                    }\n                }\n            } else {\n                handlers.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Remove all event handlers.\n     */\n    unAll() {\n        this.handlers = null;\n    }\n\n    /**\n     * Attach a handler to an event. The handler is executed at most once per\n     * event type.\n     *\n     * @param {string} event The event to listen to\n     * @param {function} handler The callback that is only to be called once\n     * @return {ListenerDescriptor} The event descriptor\n     */\n    once(event, handler) {\n        const fn = (...args) => {\n            /*  eslint-disable no-invalid-this */\n            handler.apply(this, args);\n            /*  eslint-enable no-invalid-this */\n            setTimeout(() => {\n                this.un(event, fn);\n            }, 0);\n        };\n        return this.on(event, fn);\n    }\n\n    /**\n     * Disable firing a list of events by name. When specified, event handlers for any event type\n     * passed in here will not be called.\n     *\n     * @since 4.0.0\n     * @param {string[]} eventNames an array of event names to disable emissions for\n     * @example\n     * // disable seek and interaction events\n     * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);\n     */\n    setDisabledEventEmissions(eventNames) {\n        this._disabledEventEmissions = eventNames;\n    }\n\n    /**\n     * plugins borrow part of this class without calling the constructor,\n     * so we have to be careful about _disabledEventEmissions\n     */\n\n    _isDisabledEventEmission(event) {\n        return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);\n    }\n\n    /**\n     * Manually fire an event\n     *\n     * @param {string} event The event to fire manually\n     * @param {...any} args The arguments with which to call the listeners\n     */\n    fireEvent(event, ...args) {\n        if (!this.handlers || this._isDisabledEventEmission(event)) {\n            return;\n        }\n\n        const handlers = this.handlers[event];\n        handlers &&\n            handlers.forEach(fn => {\n                fn(...args);\n            });\n    }\n}\n","/**\n * Stops propagation of click event and removes event listener\n *\n * @private\n * @param {object} event The click event\n */\nfunction preventClickHandler(event) {\n    event.stopPropagation();\n    document.body.removeEventListener('click', preventClickHandler, true);\n}\n\n/**\n * Starts listening for click event and prevent propagation\n *\n * @param {object} values Values\n */\nexport default function preventClick(values) {\n    document.body.addEventListener('click', preventClickHandler, true);\n}\n","/* eslint-disable valid-jsdoc */\n/**\n * Returns the `requestAnimationFrame` function for the browser, or a shim with\n * `setTimeout` if the function is not found\n *\n * @return {function} Available `requestAnimationFrame` function for the browser\n */\nexport default (\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    ((callback, element) => setTimeout(callback, 1000 / 60))\n).bind(window);\n","/**\n * Apply a map of styles to an element\n *\n * @param {HTMLElement} el The element that the styles will be applied to\n * @param {Object} styles The map of propName: attribute, both are used as-is\n *\n * @return {HTMLElement} el\n */\nexport default function style(el, styles) {\n    Object.keys(styles).forEach(prop => {\n        if (el.style[prop] !== styles[prop]) {\n            el.style[prop] = styles[prop];\n        }\n    });\n    return el;\n}\n"],"sourceRoot":""}